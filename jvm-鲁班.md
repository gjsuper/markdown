#jvm
* maxmemory--默认大小为当前物理内存的1/4
* totalmemory--默认大小为当前物理内存的1/64
* 伸缩区有这么大的处理范围，所以在进行堆内存的分配诶过程中，当用户访问量增加的时候一定会导致不断的判断空间是否充足，不断的进行内存空间的增长，不断地进行内存空间的收缩。
* -Xms:设置初始化的内存分配大小，-Xmx:设置最大的可用内存空间,将这俩个值设置为一样可以减*少内存的收缩操作
* -Xmn设置年轻代的大小，默认是物理内存的1/64
* -Xss：设置每一个线程所用的栈的大小
* -X:surivorRatio:设置eden区域两个存活区的大小比,默认是8:1:1
* 当堆内存空间很大的时候就要考虑gc的效率问题。考虑两个技术名称：BTP、TLAB
    - BTP：采用栈的形式，将最新创建的对象放在栈顶
    - TLAB：分块保存，适合多线程操作
* 对象很大时，会直接进入老年代，不会在年轻代保存
* jdk1.8之后取消了永久代，而变为了元空间（不再使用堆内存里保存，而是直接利用物理内存保存）

* 年轻代并行GC
    - 算法：复制-清理算法，在扫描和复制的时候均采用多线程的处理模式来完成
    - 问题：STW-产生中断，因为需要进行垃圾标记（暂停当前所有的线程，标记处垃圾，如果堆内存空间很大，那么程序挂起的时间就可能会很长）
- G1：把内存空间分成很多小块，每个小块都有年轻代和老年代，手机垃圾时
