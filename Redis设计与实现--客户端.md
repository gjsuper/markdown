# Redis设计与实现--客户端（Redis设计与实现第十三章）

* redis服务器保存了所有的clients链表，这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作、或者查找某个指定的客户端，都可以通过遍历clients链表来完成

[clients链表](/images/redis/clients链表.png)

* 套接字描述符
```C
typedef struct redisClient {
    //...
    int fd;
    //...
    //客户端名字
    robj *name;

    //flags的属性可以是单个标志（flags=<flag>），也可以是多个标志的二进制值flags=<flag1>|<flag2>|...
    int flags

    //输入缓冲区，用于保存客户端发送的命令请求
    sds querybuf;

    //命令参数,argv[0]是要执行的命令，之后是传给命令的参数 [argv属性和argc属性实例](/images/redis/argv属性和argc属性实例.png)
    robj **argv;

    //命令参数个数
    int argvc;

    //当服务器从协议中解析出argv和argc值后，服务器将根据argv[0]的值，在命令表中查找对应的命令实现函数
    struct redisCommond *cmd;

    //固定大小的输出缓冲区，REDIS_REPLY_CHUNK_BYTES默认为16*1024--16kB
    char buf[REDIS_REPLY_CHUNK_BYTES];
    //固定大小数组已使用的字节数量
    int bufPos;

    //可变大小的输出缓冲区,使用链表带来实现
    list *reply

    //客户端是否通过了身份验证，0--没通过，1--通过，只有在服务器启用了身份验证功能时，这个属性才有用
    int authenticalted;

    //创建客户端的时间
    time_t ctime;

    //客户端最后一次与服务器交互的时间，可以用来记录客户端的空转时间
    time_t lastinteraction;

    //记录输出缓冲区第一次到达软性限制（输出缓冲区大小超过了软性限制所设置的大小，但未超过硬性限制（一超出硬性限制客户端就会被服务器关闭））的时间，如果输出缓冲区的大小一致超出软性限制，并且持续时间超过服务器限制，就会关闭客户端，如果未一直超出，客户端就不会被关闭，并且obuf_soft_limit_reached_time的值会被清零）
    time_t obuf_soft_limit_reached_time;

} redisClient;
```

* fd的属性可以是-1或者大于-1
    - 伪客户端：fd的属性是-1，伪客户端的属性来源于AOF文件或者Lua脚本。用于载入AOf文件并还原数据库状态，或者用于Lua脚本中包含的Redis命令
    - 普通客户端：fd的值大于-1，普通客户端视同套接字来与服务器进行通信，所以服务器会用fd属性来记录客户端套接字的描述符。因为合法套接字的描述符不能是-1，所以普通客户端的套接字描述符的值必然大于-1
- 输入缓冲区：输入缓冲区会根据输入内容动态的缩小或扩大，但它的最大大小不能超过1GB，否则服务器会关闭这个客户端
- 输出缓冲区：执行命令所得的回复会被保存在客户端的输出缓冲区了面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个输出缓冲区的大小是可变的
    - 固定大小的缓冲区是固定的，用于保存长度比较小的回复，比如ok、简短的字符串值、整数值等等
    - 可变长度的缓冲区用于保存那些长度比较大的回复，比如一个很长的字符串、有很多项的列表、包含很多元素的集合等等.
    -
