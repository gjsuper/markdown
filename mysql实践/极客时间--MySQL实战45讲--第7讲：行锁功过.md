# 极客时间--MySQL实战45讲--第7讲：行锁功过

* 主动死锁检测，innodb_deadlock_detect的默认值本身就是on。主动死锁检测在发生死锁的时候能够快速发现并进行处理，但它有额外的负担：每当一个事务被锁的时候，就要看看他所依赖的线程有没有被别人锁住，如此循环，最后安段是否出现了循环等待，也就是死锁。
* 注意：
    - 如果他要加锁访问的行上有锁，他才要检测
    - 一致性读不会加锁，也就不需要检测
    - 并不是每次死锁检测都要扫描所有的事务，他只会检测跟自己相关的事务
            在所有事务都要更新同一行的场景下，每个新来的被堵住线程，都要判断会不会由于自己的加入导致了死锁，这是个时间复杂度为o(n)的操作。加入有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级。虽然检测的结果是没有死锁，但这期间要消耗大量的CPU资源。因此会看到CPU利用率很高，但每秒却执行不了几个事务。
* 解决由这种热点行更新导致的性能问题有两个思路
    - 如果能确保这个也业务不会产生死锁，可以临时把死锁检测关掉。
    - 控制并发，可以通过中间件来实现。
- innodb行级锁是通过锁索引记录实现的，如果列上没有索引，就会锁定整张表。
