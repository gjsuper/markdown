# 极客时间--MySQL实战45讲--第36讲：为什么临时表可以重名？

### 临时表和内存表
1. 内存表：指的是使用Memory引擎的表，建表语法creat table ...engine=memory。这种表里的数据都保存在内存里，系统重启时被清空，其他方面就是一个正常的表
2. 临时表可以使用各种引擎。如果是InnoDB和MyISAM引擎的临时表，数据是写在磁盘的。当然也可以使用Memory引擎。


### 临时表的特性
1. 建表语法是create temporary table...
2. 一个临时表只能被创建它的session访问，对其他线程是不可见的。
3. 临时表和普通表可以重名
4. session内有同名的临时表和普通表时，show create 语句，以及增删改查语句访问的都是临时表
5. show tables 不显示临时表

由于只能被创建它的session访问，所以这个session结束时，会自动删除临时表，由于这个特性，**临时表就特备适合做join优化**，因为：

1. 不同session的临时表是可以重名，可以支持讴歌session同时进行join优化
2. 不用担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库重启，还需要专门去清理中间过程生成的数据。而临时表会自动回收，不需要这个额外的操作。

### 临时表的应用

由于不用担心线程间的重名冲突，临时表经常被用于复杂查询的优化。其中分库分表的跨库查询就是其中一种。

如果一个表ht使用字段f作为分表表示（f % 1024,让一个大表分成1024个小表），但如果这个表还有一个索引k，查询语句是这样的：

    select V from ht where k >= M order by t_modified desc limit 1000

由于查询条件没有用到分区字段f，只能到所有的分区去在查找所有满足条件的数据行，然后做统一做order by。这种情况有两种思路：

1. 在proxy中间层的代码实现排序，优点是速度快，拿到分区的分区后在内存中参与计算，但缺点也明显：
    1. 开发工作量大
    2. 对proxy层夜里简答，很容易出现内存不够和CPU瓶颈的问题
2. 把各个分库的数据汇总到临时表，然后在这个表上做逻辑操作

**在实践中，往往会发现每个分库的计算量都不饱和，所以直接把临时表temp_ht放到32个分库的某一个分库上**

### 为什么临时表可以重名

    create temporary table temp_t(id int primary key) engine=innodb；
MySQL会给这个临时表创建一个frm文件以保存表结构定义，还要有地方保存数据。

这个frm表放在临时文件目录下，文件名的后缀是.from,前缀是"#sql{进程id}_{线程id}_序列号"。可以使用select @@tmpdir命令来显示实例的临时文件目录。
* 普通表的table_def_key是由“库名+表名”得到的，因此会产生重复
* 临时表的table_def_key在由“库名+表名”的基础上又加入了“server_id+ thread_id”，每个线程都不一样，因此不会重复

而表中数据的存放：
* 5.6及以前，MySQL会在临时文件目录下创建一个相同前缀、以.idb为后缀的文件用来保存数据
* 从5.7开始，MySQL引入了一个临时表空间专门用来存放临时文件的数据，因此不需要再创建idb文件了。

如果存在普通表名和临时表名一样，那么：
每个线程都维护了自己的临时表链表，这样每次session操作表时，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；session结束的时候，对链表里的每个临时表，执行“drop TEMPORARY TABLE + 表名”操作。这时，在binlog里也会记录这条drop语句。

### 临时表和主备复制
既然写到binog里了，就意味着备库需要

    create table t_normal(id int primary key, c int)engine=innodb;/*Q1*/
    create temporary table temp_t like t_normal;/*Q2*/
    insert into temp_t values(1,1);/*Q3*/
    insert into t_normal select * from temp_t;/*Q4*/
如果binlog格式是row，那么跟临时表有关的语句就不会记录到binlog里，因为row格式记录的是这个操作的数据，即：write_row_event里面记录的逻辑是“插入一行数据(1,1)”，只有binlog格式是binlog_formate=statement/mixed的时候，binlog中才会记录临时表的操作。主库操作完了临时表，线程退出 会删除临时表，但备库同步线程是持续运行的，所以需要在主库写一个DROP TEMPORARYTABLE传给备库。

主库的临时表传到备库的时候，会把主库的线程id也传过去，用于生成table_def_key，这样虽然备库所有的临时表都是由日志线程生成的，但他们的table_def_key不同，所以不会有冲突。

主库会对drop table语句进行改写：如果主库执行“drop table t_normal,tmp_t”，在binlog中就只能记录：

    DROP TABLE `t_normal` /* generated by server */
因为备库上没有临时表，要把这个命令重写再传到备库，才不会导致备库同步线程停止
