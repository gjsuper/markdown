# 极客时间--MySQL实战45讲--第21讲：为什么我只改一行数据，锁那么多？

***加锁规则***
***原则1：加锁的基本单位是next-key lock，前开后闭***
***原则2：查找过程中访问到的对象才会加锁***
***优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁***
***优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件时，next-key lock退化为间隙锁***
***一个bug：唯一索引上的范围查询会访问到不满足的第一个为止***

分析一个例子：

[desc加锁分析](../images/mysql实战45讲/desc加锁分析.png)

对于session A:
1. 由于是order by c desc，第一个要定位的是索引c上最右边的 c=20 的行（desc就是这么执行的），所以会加上间隙锁(20，25)和next-key lock（15，20]。
2. 索引在c上向左扫描（desc就是这么执行的），要扫到c=10才停下来，所以next-key lock会加到（5,10]，这正是阻塞session B的insert语句的原因。
3. 在扫描过程中，c=20，c=15，c=10这三行都存在值，由于是select *，所以会在主键id上加三行锁

因此session A的select语句锁定范围就是：
1. 索引c上（2，25）；
2. 主键索引上id=10、15、20

要知道最终的加锁是根据实际执行情况来的。所以，如果一个select * from for update语句，优化器决定决定舍弃回表，使用全表扫描，遍历主键索引，那么就会把主建索引上next-key lock全加上
