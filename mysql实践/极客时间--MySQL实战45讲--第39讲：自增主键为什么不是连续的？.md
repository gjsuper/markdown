# 极客时间--MySQL实战45讲--第39讲：自增主键为什么不是连续的？

业务设计不应依赖于自增主键的连续性，因为自增主键并不能保证连续递增
有这样一个表：

    CREATE TABLE `t` (
      `id` int(11) NOT NULL AUTO_INCREMENT,
      `c` int(11) DEFAULT NULL,
      `d` int(11) DEFAULT NULL,
      PRIMARY KEY (`id`),
      UNIQUE KEY `c` (`c`)
    ) ENGINE=InnoDB;

### 自增值在哪保存
在这个空表中插入一条数据后，再执行show create table命令，可看到：
[自动生成的auto_increment值](../images/mysql实战45讲/自动生成的auto_increment值.png)
这表示下一次插入数据的时候，如果需要自动生成自增值会生成id=2

* 在MyISAM引擎中自增值保存在数据文件中
* InnoDB引擎的自增值，其实在保存在内存里的，到了MySQL8.0以后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复之前的值”，具体情况是：
    - 在MySQL5.8之前，自增值保存在内存里，没有持久化，每次重启后，第一次打开表的时候，都会去找自增值的最大值，然后将max(id) + 1作为表当前的自增值。而mysql重启可能会修改表的AUTO_INCREMENT的值，例如表的数据里最大行的id是10，AUTO_INCREMENT的值时11，把id=10的行删掉，马上重启MySQL，AUTO_INCREMENT将变为10
    - MySQL8.0之后，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复启动前的值

### 自增值修改机制
1. 如果插入数据时id字段指定为0、null或者未指定，就把AUTO_INCREMENT值填到自增字段
2. 如果插入数据时指定了具体的指，就直接用这个值

根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值时x，当前自增值是y。
1. 如果 x < y，那么这个表的自增值不变
2. 固若x >=y，就要把自增值改为新的自增值

新的自增值生成算法：从auto_increment_offset开始，以auto_increment_increment为部长，直到找到第一个大于x的值，作为新的自增值，这两个参数的默认值都是1

    但在一些场景下，例如双M的主备结构里，可能会设置auto_increment_increment=2，让一个库的自增id是奇数，另一个库的id是偶数，避免两个库的主键发生冲突

### 自增值的修改时机
表t里面已经有了（1，1，1）这条记录，这时再执行一条数据命令：

    insert into t values(null, 1, 1)

这个语句的只能执行流程：
1. 执行器调用InnoDB引擎接口写入一行，传入的这一行的值时(0, 1, 1)；
2. InnoDB发现用户没有指定自增id的值，获取表当前的自增值2；
3. 将传入的行的值改成（2，1，1）；
4. 将表的自增值改成3；
5. 继续执行插入数据操作，由于已经存在c=1的记录，所以报Duplicate key error，语句返回。

这时，表的自增主键改为了3，但由于碰到唯一键冲突，所以id=2这一行并没有插入成功，也没有将自增值改回去，这样就出现了自增主键不连续的情况。
同样事务回滚也会出现类似的现象，下面这样：

    insert into t values(null,1,1);
    begin;
    insert into t values(null,2,2);
    rollback;
    insert into t values(null,2,2);
    // 插入的行是 (3,2,2)

MySQL之所以不支持自增主键回滚，主要是考虑到性能上的影响

假设有两个并行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增主键，肯定要加锁，然后顺序申请。
1. 假设事务a申请到了id=2，事务b申请到了id=3，这时表的自增主键是4；
2. 事务b提交了，但事务a出现了唯一键冲突
3. 如果允许自增主键回退，表的当前自增主键就改为了2，那么就会出现表里有了id=3的数据行，但表的自增主键是2
4. 接下来，其他事务执行会继续申请到id=2，然后申请到id=3，就会出现”主键冲突“的错误

解决这个问题得方法是：
1. 每次申请id前，去表里判断是否存在这个id，如果存在就跳过这个id。这个方法的成本很高，以为本来申请id是一个很快的操作，现在再去主键索引树上判断id是否存在，会降低效率
2. 把自增id的锁范围扩大，必须等到第一个事务提交完，下一个事务才能再申请自增id。但由于锁粒度太大，系统并发能力会大大下降

这两个方法都会导致性能问题，因此InnoDB放弃了回退自增id ，所以才只保证自增id是自增的，但不保证是连续的

### 自增锁的优化
自增锁并不是一个事务锁，而是每次申请完就马上释放，以提高并发度。

MySQL5.0版本的时候，自增锁的范围是语句级别的，显然会影响并发度

MySQL5.1.22引入了一个新策略，新增参数innodb_automic_lock_mode，默认值是1.
1. 参数为0时，采用5.0的策略，即语句执行结束后才释放锁
2. 参数设置为1时：
    - 普通insert 语句，自增锁在申请后立马释放
    - 类似insert...select这样的批量插入语句，自增锁还是要等语句结束后才被释放
3. 参数设置为2时，所有申请主键的动作都是申请完就释放锁

**为什么默认设置下，insert...select要使用语句级别的锁？为什么这个值不是2？**

因为这是为了数据一致性

[inser...select的场景](../images/mysql实战45讲/inser...select的场景.png)

如果sessionB申请了自增值以后立马释放自增锁，就会出现这么一种情况：
1. sessionB先插入了两个记录（1，1，1），（2，2，2）
2. 然后，sessionA申请自增id得到id=3，插入（3，5，5）
3. 之后，sessionB继续执行，插入两条记录（4，3，3），（5，4，4）


**在sessionB insert into...select时，表t需要对所有的行和间隙加锁，如果不加锁的话，虽然主库插入的数据没问题，但binlog会记录表t新增的数据，拿到备库去回放的时候，会出现数据不一致的情况（insert...seelct的数据量会变多）**

如果现在的bin_format=statement，不管是先记录A还是记录B的日志，拿到从库去执行的时候，sessionB这个语句执行出来，id都是连续的，此时，这个库就发生了数据不一致。

如何解决：
1. 让原库的批量插入语句，固定生成连续的id值。所以，自增锁之道语句执行结束才释放，就是这个目的
2. 另一种思路：在binlog中把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。这种情况就是innodb_automic_lock_mode设置为2，同时依赖binlog_format设置为row

在生产上，尤其是有insert_select这种批量插入数据的场景时，建议使用第二种方案，这样既能提高并发性，又不会出现数据一致性问题。**这里说的批量插入数据，包括insert...select, replace...select,load data语句**

普通的insert语句里面包含了多个value的情况，即使innodb_automic_local_mode=1，也不会等到语句执行完才释放锁。很为这类语句在申请id的时候，就可以精确计算出需要多少个id，然后一次性申请，时期内完后锁就可以释放了

也就是对于“insert...select”这类语句，事先不知道要申请多少个id，如果一个一个申请的话，在大批量插入的情况下，不但速度慢，并发度也低。

对于批量插入的语句，MySQL有一个批量申请id的策略：
1. 语句执行过程中，第一次申请自增id，会分配1个自增id
2. 1个用完以后，这个语句会第二次申请自增id，会分配2个
3. 2个用完了后，第三次申请会分配4个
4. 以此类推，每次申请，申请到的自增id个数都是前一次的2倍

如果最后申请到的id没用完的话，也不会回退，这也是主键id不连续的第三个原因
