# 极客时间--MySQL实战45讲--第26讲：主备为什么会延迟好几个小时
* 无论是偶发性的查询压力还是备份，对备库延迟的影响一般是分钟级的，但如果备库执行日志的速度持续低于主库生成日志的速度，那么这个延迟就有可能成了小时级别。而且对于一个压力持续比较高的主库来说，备库可能永远也追不上主库的节奏
* 在官方的5.6版本之前，MySQL只支持单线程复制，由此主库并发高，TPS高时就会出现严重的主备延迟问题


[主备流程图](../images/mysql实战45讲/主备流程图.png)
在主库，由于Innodb支持行锁，所以除了所有的事务都更新同一行，他对业务的并发的耗时很友好的，但日志备库执行时，如果采用单线程，就会导致备库应用日志不够快，造成主备延迟

[多线程模型](../images/mysql实战45讲/多线程模型.png)
&emsp;&emsp;上图中，coodinator就是原来的sql_thread，不过现在他不在直接更新数据了，只负责读取中转日志和分发事务。
&emsp;&emsp;不能采用轮询分发事务给各个worker，因为worker事务执行顺序不一定，在主库和备库上顺序相反，会导致主备不一致。
&emsp;&emsp;不能把同一个事务的多个更新语句分给多个worker，因为备库上的查询可能会看到这个事务更新了一半的结果。

**coodinator在分发的时候，需满足的两个基本原则**
**1.不能造成更新覆盖。这要求更新同一行的两个事务，必须被同一个worker中**
**2.同一个事务不能被分开，必须放到同一个worker中**

* MySQL5.6版本的并行复制策略
&emsp;&emsp;MySQL5.6支持了并行复制，只支持按库并行。
&emsp;&emsp;相比于按表和按行的优势：
1. 构造hash值的时候速度很快，只需要库名
2. 不要求binlog格式。因为statement格式的binlog也可以很容易拿到库名
但如果所有的数据都在一个库里，这个策略就没有效果了
* MariaDB的并行复制策略
利用了redo log的组提交的特性：
1. 能够在同一组里提交的事务，一定不会需改同一行
2. 主库上可以并行执行的事务，备库上也一定是可以并行执行的
在实现上：
1. 在一组里面一起提交的事务，有一个相同的commit_id
2. commit_id直接写到binlog里面
3. 传到备库应用的时候，相同commit_id的事务被分发到多个worker执行
4. 这一组全部执行完成后，coodinator再去取下一批
缺陷：
1. 在备库上执行的时候，要等第一组事务执行完后，第二组事务才能开始，这样吞吐量就不够
2. 容易被大事务拖后腿。同一组事务只有等到所有事务执行完后才能开始下一组事务，容易被一个大事务卡住，这时就只有一个worker在执行，浪费资源,见下图

[主库并行事务](../images/mysql实战45讲/主库并行事务.png)
[MariaDB并行复制](../images/mysql实战45讲/MariaDB并行复制.png)

* MySQL5.7的并行复制策略
&emsp;&emsp;MySQL5.7提供了slave_parallel_type参数来控制并行复制策略：
1. 配置为DATABASE，表示使用5.6版本的按库并行策略
2. 配置为LOGICAL_CLOCK，表示类似MariaDB的策略，但做了一点优化
问题：同时处于“执行状态”的所有事物，是不是可以并行？
答：不能。因为这里面可能有所冲突而处于等待状态的事务。如果这些事务在备库上被分配到不同的worker，就会出现跟主库不一致的情况。MariaDB这个策略的核心就是“所有处于commit状态的事务可以并行。事务处于commit状态，表示已经通过了锁冲突的验证”

[两阶阶段提交过程图](../images/mysql实战45讲/两阶阶段提交过程图.png)
其实，不用等到commit阶段，只要能够达到redo log prepare阶段，就表示事务已经通过了锁冲突的检验。

MySQL5.7的思想：
1. 同时处于prepare状态的事务，在备库是上可以并行执行的。
2. 处于prepare状态的事务，与处于commit状态的事务之间，在备库上也是可以并行执行的。

* MySQL5.7.22的并行复制策略
&emsp;&emsp;MySQL5.7.22新增了一个新的并行复制策略，基于WRITESET的并行复制。同时新增了binlog-transaction-dependency-tracking，用来控制是否启用在这个新策略，他的值有：
1. COMMIT_ORDER,就是刚提到的，根据同时进入prepare和commit来判断是否可以并行的策略。
2. WRITESET，表示的是对于事务设计更新的每一行，计算出这一行的hash值（根据“库名+表名+索引名+值”计算出来的），组成集合writeset。如果两个事务没有操作相同的行，也就是说他们的writeset没有交集，就可以并行。
3. WRITE_SESSION,在WRITESET的基础上加了一个限制，在主库上同一个线程先后执行的两个事务，在备库上执行的时候，要保证相同的先后顺序。
