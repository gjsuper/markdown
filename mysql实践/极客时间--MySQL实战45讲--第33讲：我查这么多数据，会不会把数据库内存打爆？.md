# 极客时间--MySQL实战45讲--第33讲：我查这么多数据，会不会把数据库内存打爆？

我的主机内存只有100G，现在对一个200G的大表做全表扫描，会不会把数据库内存用光？

想一下：做逻辑备份的时候，就是做全表扫描，如果会把内存吃光，逻辑备份不是早就出挂了？所以看起来，对大表做全表扫描是没问题的

## 全表扫描对server层的影响
现在对一个200G的InnoDB表db1.t执行全表扫描：

        select * from db1.t
由于没有其他判断条件，所以查到的每一行都可以直接放到结果集里面，然后返回到客户端，这个结果集存在哪里呢？实际上，服务端并不需要保存一个完整的结果集。取数据和发数据的流程是这样的：

1. 取一行数据，写到net_buffer中。这块内存的大小是由参数net_buffer_length定义的，默认16K.
2. 重复取数据行，之道net_buffer写满，调用网络接口发出去
3. 如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer
4. 如果发送函数返回EAGAIN或WSAEWOULDBLOCK，即表示本地网络战（socket send buffer）写满了。直到网络栈重新可写，再继续发送

从这个流程可看到：
1. 查询过程中，占用的MySQL内部的内存最大就是net_buffer_length这么大，不会达到200G
2. socket send buffer 也不可能达到200G，如果socket send buffer 写满，就会暂停读取数据的流程

也就是说，**MySQL是边读表发的**，如果客户端接收的慢，会导致MySQL服务端数据发送不出去，这个事务的执行时间会变长

## 全表扫描对InnoDB的影响

WAL机制中，InnoDB内存的一个作用是保存更新的结果，再配合redo log，就避免了随机写盘。内存数据页是在Buffer Pool中管理的，在WAL中，BUffer Pool起到了加速更新的作用。而实际上Buffer Pool的另一个更重要的作用是加速查询。

由于WAL机制，当食物提交的时候，磁盘的数据页是旧的，如果这时来了一个查询读这个数据页，不需要马上把redo log应用到数据页，因为这时内存数据页的结果是最新的，直接读内存页就可以，不需要读盘，所以速度很快，因此Buffer Pool有加速查询的作用

**内存命中率**。因为InnoDB Buffer Pool 的大小是由参数innodb_buffer_pool_size决定的，所以innodb_buffer_pool_size小于磁盘的数据量是很常见的。如果一个Buffer Pool满了，要冲磁盘读入一个数据页，那肯定要淘汰一个旧的数据页。

InnoDB内存管理使用最近最少使用（Last Recenttly Used，LRU）算法

[LRU算法](../images/mysql实战45讲/LRU算法.jpg)

**但在全表扫描的时候，扫描一个200G的表，而这个表是一个历史数据表，平时没有业务访问他，按照这个算法，Buffer Pool里的数据都要被淘汰掉，以存入扫描过程总访问到的数据页的内容，这会导致正常的业务访问请求的内存命中率急剧下降，磁盘压力增加，SQL语句响应变慢**

基于上述情况，InnoDB对LRU算法做了改进
[改进的LRU算法](../images/mysql实战45讲/改进的LRU算法.png)

InnoDB把LRU链表分成了young区和old区，图中LRU_old指向的就是old区域的第一个位置，值整个链表的5/8处。

流程：
1. 要访问数据页P3,由于P3在young区，因此和优化前的LRU算法一样，将其移动到链表头部
2. 时候访问一个不存在的数据页，这时淘汰数据页Pm，但是心插入的数据页Px，是放在LRU_old处
3. 处于old区域的数据页，每次访问的时候都要做如下判断：
    * 若这个数据页在LRU中存在的时间超过1s，就把他移动到链表头部
    * 若短于1s，就保持位置不变。1s这个参数由innodb_old_blocks_time控制，默认值是1000ms。

因此全表扫描的时候：
1. 扫描过程中，需要插入的新数据页，都被放到old区
2. 一个数据页有很多条数据，这个数据页会被多次访问到，但由于是顺序扫描，时间不会超过1s，因此还是会被保留在old区
3. 之后继续扫描别的数据页，之前的数据页再也不会被访问到，于是始终没有机会移到头部，很快就会被淘汰掉

整个过程中，虽然也用到了Buffer Pool，但对young区完全没影响，不会影响到正常业务的内存命中率
