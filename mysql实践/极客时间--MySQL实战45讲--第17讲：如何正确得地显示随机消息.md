# 极客时间--MySQL实战45讲--第17讲：如何正确得地显示随机消息

* 从单词库中随机选出三个单词（表名称为words，里面有1000行数据，有主键id和word两个字段）：

        mysql> select word from words order by rand() limit 3;
执行情况：[命令执行情况](../images/mysql实战45讲/命令执行情况.png)
可以看到它使用了临时表，需要执行排序操作。也就是需要临时表，并且在临时表上排序
&emsp;&emsp;这个语句的执行过程如下：
1. 创建一个临时表。这个临时表使用memory引擎，表里有两个字段，一个是double类型，记为字段R，第二个字段是varchar(64)类型，记为字段W。并且，这个表没有索引。
2. 从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并把这个小数和word值分别存入临时表的字段R和W中，到此扫描行数是1000行。
3. 现在临时表有10000行数据，接下来要在没有索引的内存临时表上，按照字段R排序。
4. 初始化sort_buffer。在sort_buffer中有两个字段，一个是double类型，另一个是整形
5. 从内存临时表中一行一行读出R值和位置信息，分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全扫描，到此时，扫描的总行数为20000行
6. 在sort_buffer中根据R的值进行排序。这个过程没有涉及到表操作，所以不会增加扫描行数
7. 排序完成后，取出前三个结果的位置信息，依次到内存临时表取出word值，返回给客户端。在这个过程中，访问了三行数据，总扫描行数为20003行。

随机排序过程的示意图为：
[随机排序过程](../images/mysql实战45讲/随机排序过程.jpg)
这里order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法

* 磁盘临时表

&emsp;&emsp;tmp_table_size这个配置限制了内存临时表的大小，默认16M，如果超过了，就会转为磁盘临时表
&emsp;&emsp;mysql5.6以后引入了新的排序算法：优先队列排序算法（堆排序），其实现在的sql语句，主需要取R值最小的3个rowid。但是，如果使用归并排序算法的话，虽然最终也能得到前3个值，但这个算法结束后，已经将10000行数据都排序好了

&emsp;&emsp;上一篇文章中的SQL查询语句

    select city,name,age from t where city='杭州' order by name limit 1000  ;
虽然也用到了limit，但没有使用优先队列排序，因为这条sql是limit1000，如果使用优先队列散发，需要维护堆的大小就是1000，超过了sort_buffer_size的大小，所以只能使用归并排序算法。
