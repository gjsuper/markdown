# 极客时间--MySQL实战45讲--第20讲：幻读是什么，幻读有什么问题


表结构：

    CREATE TABLE `t` (
    `id` int(11) NOT NULL,
    `c` int(11) DEFAULT NULL,
    `d` int(11) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `c` (`c`)
    ) ENGINE=InnoDB;

    insert into t values(0,0,0),(5,5,5),
    (10,10,10),(15,15,15),(20,20,20),(25,25,25);


![假设只在id=5加行锁](../images/mysql实战45讲/假设只在id=5加行锁.png)

&emsp;&emsp;由于select for update会查询所有的行，而且使用的是当前读，并且加上写锁。
&emsp;&emsp;其中，Q3读到id=1这一行的现象，被称为“幻读”。也就是说，幻读指的是一个事务在前后两次查询同一个范围的时候，后一个查询看到了前一个查询没有出现的行。

***1.在可重复读的级别下，普通的查询时快照读，是看不到别的事务插入的数据的。因此幻读只在“当前读”才会出现***</br>
***2.上面session B的修改结果，被session A读了出来，不能成为幻读。幻读仅专指新插入的行*****

* 幻读的问题：
    1. 语义被破坏了，Session A在T1时刻就申明了，“我要把所有d=5的行锁住，不准别的事务进行读写操作。而实际上，这个语义被破坏了。”
    2. 数据一致性的问题。数据库的数据和binlog中的日志恢复出来的数据不一致，会导致从库的数据与主库不一致。
* 把所有的记录都加上锁，还是阻止不了幻读，因为幻读是新插入的数据导致的，加锁只能给已有的数据加锁。
* 如何解决幻读？新插入的数据插在了数据与数据之间，通过next-key lock来解决，即间隙所+行锁。
