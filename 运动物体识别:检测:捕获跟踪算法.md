###1. ViBe

#### 1.1 简介

&emsp;&emsp;ViBe是一种运动目标检测算法，该算法主要不同之处是背景模型的更新策略，随机选择需要替换的像素的样本，随机选择邻域像素进行更新。在无法确定像素变化的模型时，随机的更新策略，在一定程度上可以模拟像素变化的不确定性。
#### 1.2 算法原理
&emsp;&emsp;算法采用邻域像素来创建背景模型，通过比对背景模型和当前输入像素值来检测前景，可以细分为三个步骤：       
##### 1.2.1  背景模型的初始化
&emsp;&emsp;初始化单帧图像中每个像素点的背景模型，ViBe算法主要是利用单帧视频序列初始化背景模型，对于一个像素点，结合相邻像素点拥有相近像素值的空间分布特性，随机的选择它的邻域点的像素值作为它的模型样本值

，假设每一个像素和其邻域像素的像素值在空域上有相似的分布。基于这种假设，每一个像素模型都可以用其邻域中的像素来表示。为了保证背景模型符合统计学规律，邻域的范围要足够大。当输入第一帧图像时，即t=0时，像素的背景模型

      其中，表示空域上相邻的像素值，表示当前点的像素值。在N次的初始化的过程中，中的像素点被选中的可能次数为L=1,2,3,…,N。

####1.2.2 前景检测
&emsp;&emsp;对后续的图像序列进行前景目标分割操作。当t=k时，像素点的背景模型为，像素值为。按照下面判断该像素值是否为前景。

&emsp;&emsp;这里上标r是随机选的；T是预先设置好的阈值。当满足符合背景#N次时，我们认为像素点为背景，否则为前景。

      第三步，背景模型更新方法。ViBe算法的更新在时间和空间上都具有随机性。      时间上的随机性。在N个背景模型中随机抽取一个，设为图像，图2-1表示了图像的x位置及其八邻域内的像素。当我们得到新的一帧图像时，如果图像中的x位置对应的像素被判断为背景，则需要被更新。这个抽取的过程体现了时间上的随机性。空间上的随机性。在的八邻域中随机抽取一个像素，用的来替换掉，这体现了模型更新空间上的随机性。

    以上便是更新的过程，即用来更新及其八邻域。采用八邻域更新的方法，可以去除由于获取的视频细微抖动（摄像机抖动、目标微动）而产生的重影和误差，让检测目标更加准确。

###2. TLD
####2.1 简介
    TLD算法主要由三个模块构成：追踪器（tracker），检测器（detector）和机器学习（learning)
####2.2 算法原理
&emsp;&emsp;TLD算法主要由三个模块构成：追踪器（tracker），检测器（detector）和机器学习（learning）。
&emsp;&emsp;追踪器的作用是跟踪物体的运动，当物体始终可见时跟踪器才会有效。追踪器根据物体在前一帧已知的位置估计在当前帧的位置，这样就会产生一条物体运动的轨迹，从这条轨迹可以为学习模块产生正样本（Tracking->Learning）。
&emsp;&emsp;检测器的作用是估计追踪器的误差，如果误差很大就改正追踪器的结果。检测器对每一帧图像都做全面的扫描，找到与目标物体相似的所有外观的位置，从检测产生的结果中产生正样本和负样本，交给学习模块（Detection->Learning）。算法从所有正样本中选出一个最可信的位置作为这一帧TLD的输出结果，然后用这个结果更新追踪器的起始位置（Detection->Tracking）。
&emsp;&emsp;学习模块根据追踪器和检测器产生的正负样本，迭代训练分类器，改善检测器的精度（Learning->Detection）。


TLD

     TLD（Tracking-Learning-Detection）是一种高准确率的实时长时捕获跟踪算法，该算法所需的先验知识极少，并能适应跟踪目标的变化，能够快速学习目标特征并实现高效的捕获跟踪。

参考资料：https://docs.opencv.org/3.3.0/d2/d33/classcv_1_1MultiTrackerTLD.html

   https://www.cnblogs.com/huty/p/8519325.html

Background subtraction（背景减法）

      它的基本思想和帧间差分法相类似，都是利用不同图像的差分运算提取目标区域。不过与帧间差分法不同的是，背景减法不是将当前帧图像与相邻帧图像相减，而是将当前帧图像与一个不断更新的背景模型相减，在差分图像中提取运动目标。

      参考资料：https://www.w3cschool.cn/opencv/opencv-2v342ebv.html

                        https://www.cnblogs.com/lvxiaoning/p/8038234.html

KNN

      找到最近的k个邻居（样本），在前k个样本中选择频率最高的类别作为预测类别

      参考资料：http://www.zoranz.net/Publications/zivkovicPRL2006.pdf

          https://github.com/opencv/opencv/blob/master/modules/video/src/bgfg_KNN.cpp
