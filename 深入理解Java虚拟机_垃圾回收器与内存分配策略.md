##GC Roots：
* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中引用的对象

##应用类型
* 强引用：new
* 软引用：软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围中进行第二次回收，如果这次回手之后还是没有足够的内存，会抛出内存溢出异常。
* 弱引用：他关联的对象只能存活到下一次垃圾回收之前，不管内存是否足够，都会被回收掉

## 回收过程
&emsp;&emsp;真正宣告一个对象死亡，至少需要两次标记过程：如果对象在进行第一次可达性分析后发现没有雨GCRoots相连接的引用，那他将会被第一次标记并进行筛选，筛选条件是是否覆盖了finalize()。当对象没有覆盖或者finalize()已被调用，虚拟机将这两种情况视为没有必要执行。
&emsp;&emsp;如果这个对象被判定有必要执行finalize()，则会将对象放入F-Queue的队列中，并在稍后由一个虚拟机自动创建的、低优先级的Finalizer线程去执行它。

##回收方法区（方法区）
&emsp;&emsp;**回收内容:废弃常量和无用的类。**
&emsp;&emsp;废弃常量:没有任何对象引用常量池中的对象，也没有其他地方引用了这个字面量。
&emsp;&emsp;无用的类：
1. 该类的所有实例都被回收，也就是堆中不存在该类的任何实例
1. 该类的类加载器ClassLoader已被回收
2. 该类对应的java.lang.Class对象没在任何一个地方被引用，无法在任何地方通过反射访问该类的方法。

##中断方式
* 抢先式中断：在GC发生时，首先把所有的线程中断，如果发现有线程不在安全点上，就让他跑到安全点。
* 主动式中断：当GC需要中断线程时，不直接对线程进行操作，仅仅简单的设置一个的标志，各个线程执行时区轮询这个标志，发现中断标志为真时把自己中断挂起，轮询标志和安全点是重合的，另外再加上创建对象需要分配内存的地方。

##安全区域
&emsp;&emsp;安全区是指在一段代码片段之中，引用关系不会发生变化，在这个区域任何地方开始GC都是安全的。
&emsp;&emsp;线程处于Sleep或Blocked状态，这是线程无法响应JVmware放入中断请求，“揍”到安全点的地方挂起，JVM也不可能等待线程被重新分配CPU的时间。
&emsp;&emsp;线程执行到safe regin时，标志自己已进入到安全区，那样，当在这段时间里JVM要发起GC时，就不用管标志自己为safe regin状态的线程了，当线程要离开safe regin 时，他要检查系统是否已经完成了根节点的枚举。，如果完成了，线程就继续执行，否则线程等待直到收到可以离开安全区的信号为止。

##垃圾回收器
[垃圾回收器](E:\git\markdown\images\java虚拟机\垃圾回收器.PNG)