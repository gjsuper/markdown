##1. GC Roots：
* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中引用的对象

##2. 应用类型
* 强引用：new
* 软引用：软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围中进行第二次回收，如果这次回手之后还是没有足够的内存，会抛出内存溢出异常。
* 弱引用：他关联的对象只能存活到下一次垃圾回收之前，不管内存是否足够，都会被回收掉

## 3. 回收过程
&emsp;&emsp;真正宣告一个对象死亡，至少需要两次标记过程：如果对象在进行第一次可达性分析后发现没有雨GCRoots相连接的引用，那他将会被第一次标记并进行筛选，筛选条件是是否覆盖了finalize()。当对象没有覆盖或者finalize()已被调用，虚拟机将这两种情况视为没有必要执行。
&emsp;&emsp;如果这个对象被判定有必要执行finalize()，则会将对象放入F-Queue的队列中，并在稍后由一个虚拟机自动创建的、低优先级的Finalizer线程去执行它。

##4. 回收方法区（方法区）
&emsp;&emsp;**回收内容:废弃常量和无用的类。**
&emsp;&emsp;废弃常量:没有任何对象引用常量池中的对象，也没有其他地方引用了这个字面量。
&emsp;&emsp;无用的类：
1. 该类的所有实例都被回收，也就是堆中不存在该类的任何实例
1. 该类的类加载器ClassLoader已被回收
2. 该类对应的java.lang.Class对象没在任何一个地方被引用，无法在任何地方通过反射访问该类的方法。

##5. 中断方式
* 抢先式中断：在GC发生时，首先把所有的线程中断，如果发现有线程不在安全点上，就让他跑到安全点。
* 主动式中断：当GC需要中断线程时，不直接对线程进行操作，仅仅简单的设置一个的标志，各个线程执行时区轮询这个标志，发现中断标志为真时把自己中断挂起，轮询标志和安全点是重合的，另外再加上创建对象需要分配内存的地方。

##6. 安全区域
&emsp;&emsp;安全区是指在一段代码片段之中，引用关系不会发生变化，在这个区域任何地方开始GC都是安全的。
&emsp;&emsp;线程处于Sleep或Blocked状态，这是线程无法响应JVmware放入中断请求，“揍”到安全点的地方挂起，JVM也不可能等待线程被重新分配CPU的时间。
&emsp;&emsp;线程执行到safe regin时，标志自己已进入到安全区，那样，当在这段时间里JVM要发起GC时，就不用管标志自己为safe regin状态的线程了，当线程要离开safe regin 时，他要检查系统是否已经完成了根节点的枚举。，如果完成了，线程就继续执行，否则线程等待直到收到可以离开安全区的信号为止。

##7. 垃圾回收器
[垃圾回收器](E:\git\markdown\images\java虚拟机\垃圾回收器.PNG)
###7.1 Serial收集器
&emsp;&emsp;单线程收集器，“stop the world”，是虚拟机运行在Client模式下的默认新生代收集器。
### 7.2 ParNew收集器
&emsp;&emsp;ParNew是Serial收集器的多线程版，是Server模式下的虚拟机中首选的新生代收集器。其中一个与性能无关的原因是，除了Serial收集器，只有ParNew能与CMS收集器配合。

###7.3 Parallel Scavenge收集器
&emsp;&emsp;他是新生代收集器，也使用复制算法，并且多线程收集。
&emsp;&emsp;但它的关注点不同，CMS等收集器的关注点是缩短Gc时用户线程停顿的时间，而parallel Scavenge的关注点是达到可控的吞吐量。它是通过调整新生代的内存大小来实现的。
&emsp;&emsp;GC自适应的调整策略。

###7.4 Serial Old
&emsp;&emsp;他是Serial的老年代版本，单线程收集器，使用标记-整理算法，它的主要意义是给Client模式下的虚拟机使用。
&emsp;&emsp;其他两大用途：在JDK1.5之前和Parallel Scavenge 配合使用，另一个用途是作为CMS收集器的后备方案，在并发收集发生Concurrent Mode failure时使用。

###7.5 Parallel Old
&emsp;&emsp;他是Parallel的老年代版本，使用多线程和标记-整理算法。
&emsp;&emsp;在JDk1.6之后提供，他出现后，在注重吞吐量以及资源敏感的场合，都可以优先考虑Parallel Scavenge 加 Parallel Old的组合。

###7.5 CMS收集器
&emsp;&emsp;CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器，基于“标记-清理”算法。
&emsp;&emsp;包括四个步骤：
1. 初始标记（CMS initial mark）：stop the world，仅仅标记GC Roots能直接关联到的对象
1. 并发标记（CMS concurrent mark）：进行GC roots tracing
2. 重新标记（CMS remark）：stop the world，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。
3. 并发清除（CMS concurrent sweep）

&emsp;&emsp;整个过程最耗时的是并发标记和并发清除，这两个过程用户线程可以和收集线程一起执行，所以总体上CMS内存回收过程和用户线程是一起执行的。

&emsp;&emsp;**缺点：**
* CMS收集器对CPU资源非常敏感:CMS默认占用的线程数是（CPU总数 + 3）/ 4,为了应付单CPU下，收集线程占用全部CPU的情况，设计了增量式并发收集器i-CMS，即在并发标记和清理时，让收集线程和用户线程交替运行。
* CMS无法清理浮动垃圾：可能导致“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于在CMS并发清理垃圾时，用户线程也在运行，可能会产生垃圾，这部分清理不掉。也就是需要预留足够的空间给用户线程使用，因此CMS无法向其他垃圾回收器一样等待老年代完全被沾满了才进行回收，需要预留一部分给垃圾回收时的用户线程使用。在JDk1.6中,CMS阈值以提高至92%，要是在CMS运行期间无法满足内存需求，会致“Concurrent Mode Failure”，这是虚拟机会启动预备方案：临时启用Serial Old收集器来重新进行老年代的回收。
* CMS基于“标记-清除”算法，意味着垃圾回收结束后会有大量空间碎片产生。空间碎片过多，会导致明明老年代有足够的空间，但没有连续的哇内存空间来分配大对象，而提前导致Full GC的发生。CMS提供了-XX：USeCMSCOmpactAtFullCollection（默认开启）：在CMS收集器顶不住要进行FULL GC时开启内存碎片整理合并过程，内存整理无法并发，只能暂停用户现场，停顿时间不得不变长。虚拟机提供了-XX:CMSFullGCsBeforeCompaction,来设置执行多少次不压缩的Full GC后，跟着来一次压缩的FULL GC，默认是0：每次FULL GC后都进行碎片压缩。

###7.6 G1收集器
**特点：**
* 并行与并发：部分其他收集器原本需要停顿Java线程来执行的GC操作，G1收集器任然可以通过并发的方式让Java程序继续执行。
* 分代收集：分代在G1中国得到了保留。虽然G1可以不需要其他收集器的配合就可以独立管理GC堆，但它能够采取不同的方式区处理新创建的对象和熬过多次GC的旧对象以取得更好的收集效果。
* 空间整合：与CMS的“标记-清理”算法不同，G1从整体上看是基于“标记-整理”的，从局部上看是基于“复制”的。这两种算法都不会产生空间碎片。
* 可预测的停顿：这是G1相对与CMS的另一个优势。G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。这几乎是实时垃圾收集器的特征。

G1之前的收集器收集范围都整个是新生代或者老年代，在G1中内存布局发火说呢过了变化，他讲整个Java堆分为多个大小相等的独立区域（Regin），虽然还保留新生代和老年代的概念，但他们不再是物理隔离的了，他们都是一部分Regin的集合（可以不连续）。

**回收步骤：**
1. 初始标记：仅标记一下GC Roots能直接关联到的对象，并修改TAMS（Next Top at mark Start）的值，让下一阶段用户程序并发运行
2. 并发标记：
3. 最终标记：
4. 筛选回收：

##内存分配与回收策略
###一般分配策略
&emsp;&emsp;大多数情况下，对象在新生代Eden区中分配，Eden空间不够分配时，发起Minor GC。大对象直接进入老年代，长期存活对象进入老年代。
###动态对象年龄判定
&emsp;&emsp;为了更好的适应不同程序的内存情况，虚拟机并不是永远要求对象的年龄达到MaxTenuringThreshold才能晋升到老年代，如果在Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，则年龄大于等于该年龄的对象就可以直接进入到老年代，无需等到MaxTenuringThreshhold要求的年龄。
###空间分配担保
&emsp;&emsp;在发生Minor GC之前，虚拟机会先检查老年代的最大可用连续空间是否大于新生代所有对象的总空间，如果是，则Minor GC可以确保是安全的。如果不是，虚拟机会查看**HandlPromotionFailure**的设置值是否允许担保失败。如果允许，那么虚拟机会继续检查老年代的最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行Minor GC，如果小于或者HandlPromotionFailure设置不允许冒险，这是要进行一次**FULL GC**。

&emsp;&emsp;**在JDK6 Update 24 之后，虽然源码中还定义了HandlePromotionFailure，但代码中已经不会再使用它了，只要老     年代的连续空间大于新生代对象或者历次晋升放入平均大小就会进行Minor GC，否则进行Full GC **