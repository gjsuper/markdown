# 16.多线程调优（下）：如何优化多线程上下文切换？

### 锁竞争优化
1. 减少锁的持有时间
2. 降低锁的粒度：读写锁
3. 用非阻塞乐观锁代替竞争锁：CAS是一个无锁算法的实现，保障了对一个共享变量读写操作的一致性。Java的Atomic包就是使用了CAS，不需要额外加锁。而JVM将Synchronized同步锁分为偏向锁、轻量级锁、自旋锁以及重量级锁，优化路径也是按上述顺序进行的

### wait/notify优化
用notify代替notifyAll。因为notifyAll会唤醒所有的阻塞线程，而大多数线程是获取不到锁的，从而硬气不必要的上下文切换。

### 合理设置线程池的大小
线程池太大了会产生过多的线程，一旦数量超过了处理器数量，就会导致过多的上下文切换。

### 使用协程实现非阻塞等待
协程是一种比线程更加轻量的东西，相比于操作系统内核来管理进程和线程，协程则完全由程序本身控制，也就是在用户态执行，就避免了像线程那样的上下文切换。

### 减少虚拟机的垃圾回收
很多垃圾回收器（serial收集器、ParNew收集器）在回收旧对象时，会产生内存碎片，从而需要进行内存整理，在合格过程中就需要移动存活的对象。而移动对象会导致内存的地址发生变化，因此在移动前需要暂停线程，在一定完成后再唤醒线程。因此减少JVM垃圾回收的频率能减少上下文切换。
