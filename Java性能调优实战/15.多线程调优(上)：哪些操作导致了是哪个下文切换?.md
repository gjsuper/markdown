# 15.多线程调优(上)：哪些操作导致了是哪个下文切换？

这种在线程切入切出的过程中，操作系统需要保存和恢复相应的进度信息，这个进度信息就是“上下文”

[线程生命周期](../images/Java性能调优实战/线程生命周期.png)

线程状态由RUNNING转为BLOCKED或者由BLOCKED转为RUNNABLE，这又是什么诱发的呢？

一种是程序本身触发的切换，称为自发性上下文切换，另一种是系统或者虚拟机诱发的非自发行上下文切换。

自发性上下文切换：
* sleep()
* wait()
* yield()
* join()
* park()
* synchronized()
* lock

非自发性上下文切换是由于调度器的原因被迫切出。常见的有：线程被分配的时间片用完，虚拟机垃圾回收导致或者执行优先级的问题导致。

“虚拟机垃圾回收导致上下文切换”：因为垃圾回收可能会导致stop-the-world，这其实是一种线程暂停行为

Synchronized会引发进程间的切换：因为锁的竞争太激烈会导致锁升级为重量级锁，未抢到锁的线程会进入到monitor，而monitor依赖底层操作系统的mutex lock，获取锁时会发生用户态和内核态的切换，所以会发生进程建的上下文切换。
