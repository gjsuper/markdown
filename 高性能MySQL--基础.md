#高性能MySQL--基础

##1. ACID
    - 原子性（Atomicity）：一个事务被视为一个单独法人内部“不可分”的工作单元
    * 一致性（Consistency）：数据库总是从一种一致性状态换到另一种一致性状态。因为事务没有提交，任何在事务处理过程中所作的数据改变都不会影响到数据库的内容。
    * 隔离性（Isolation）：某个事务的结果只有在完成之后才对其他事务可见。
    * 持久性（Durability）：一旦一个事务提交。事务所作的数据改变将是永久的。
##2. 隔离级别
    * READ UNCOMMITTED（读取未提交内容）：脏肚
    * READ COMMITTED（读取提交内容）：一个事务在开始时，只能看见已经提交事务所作的改变，一个事务从开始到提交前，所作的改变都是不可见的，除非已经提交。这也意味着**不可重复读**,即用户运行统一语句两次，会看到不同的结果。
    * REAPEATABLE READ（可重复读）：MySQL的默认事务隔离级别。他确保统一事务的多个实例在并发读取数据时，会看到同样的数据。单会导致另一个问题：**幻读**，即在用户读取某一范围的数据行时，另一事务在该范围内插入了新行，当用户再次读取该范围的数据行时，会发现新的幻影行。InnoDB和Falcon通过多版本并发控制机制解决了幻读问题。
    * SERIALIZABLE（可串行化）：通过强制事务排序，使其不可能互相冲突，从而解决幻读问题。

| 隔离级别 | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| :----: | :----: | :----: | :----: | :----: | :----: |
|READ UNCOMMITTED|是|是|是|否|
|READ COMMITTED|否|是|是|否|   
|REAPEATED READ|否|否|是|否|
|SERIALIZABLE|否|否|否|是|
##3.读写锁
 &emsp;&emsp;写锁比读锁具由更高的优先级，即使读操作用户已排在队列中，一个申请的写锁人可以排在锁队列的前列（写锁会被安置读锁之前，而读锁不能排在写锁之前）
##4. 事务日志</br>
&emsp;&emsp;预写式日志（write-Ahead Logging，利用两次磁盘写入操作把数据写入磁盘）事务日志使得事务处理过程更加高效。和每次已改数据就更新磁盘中表数据不同，存储引擎可以先更新数据在内存中的拷贝。然后，存储引擎将数据改变记录写入事务日志，因为追加日志事务导致的写操作只涉及磁盘上很小区域上的顺序IO，从而代替了写磁盘中表所需要的大量随机IO，所以速度很快。最后，相关进程还在某个时间把数据表更新到磁盘上。
##5. 多版本并发控制
&emsp;&emsp;MVCC（Multiversion Concurrency Control）式通过及时保存某些时刻的数据快照实现的。
&emsp;&emsp;InnoDB通过为每个数据行增加两个隐含值得方式来实现MVCC。这两个值代表行的创建时间和过期时间（删除时间）。每次开始新事务时，版本号会自动递增，每个事务会保存它开始时的“当前系统版本”，每个查询会根据事务的版本号，检查每行数据的版本号。</br>
&emsp;&emsp;例如：在事务级别为REAPEATABLE READ时，MVCC在实际操作中的应用方式。</br>
* SELECT:只查找创建时间早于当前版本的数据行，确保数据是在该事务之前已存在的，或者由本事务创建或修改。数据行的删除版本必须是未定义的，或者大于本事务版本。
- INSERT：为每个添加行记录当前系统版本号。
- DELETE：为每个删除行记录当期系统版本号。
- UPDATE：为每个需要更新的行建立一个新的行拷贝，在创建时间记录当前的版本号。同时更新旧的行，在删除事件例句删除版本号为该系统版本号。


&emsp;&emsp;MVCC只工作在REPEATABLE READ和READ COMMITTED两个隔离级别下。READ UNCOMMITTED不兼容MVCC，因为他之间会读取最新版本的数据，不会读取满足事务版本的数据。SERIALIZABLE也不兼容MVCC，因为该机被吓的所有读操作会对每一个返回行进行加锁。

##6.MyISAM特性
* 解锁和并发：MyISAM是表锁而不是行锁，读取时在所有表上都可以获得共享锁，而写入程序尅获得排它锁。用户在select查询时，可以在同一张表内插入新行。
* 自动修复：MySQL支持对MYISAM表的自动检查和自动修复。
* 手工修复：使用CHECK TABLE、REPAIR mytable检查表中的错误。
* 索引特性：给予BLOB获TEXT的Ian500个字符创建索引。支持全文索引。
Å˛ÅÅÅ
