#Java内存区域
##1. 运行时数据区域
###1.1 程序计数器
&emsp;&emsp;可以看做是当前线程所执行的字节码的行号指示器，线程私有，是唯一没有OutOfMemoryError的区域
###1.2 java虚拟机栈
&emsp;&emsp;线程私有，生命周期与线程相同；每个方法在运行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成，对应着一个栈帧从在虚拟机中入栈到出栈的过程
&emsp;&emsp;如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlow异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存空间，就会抛出OutOfMemoryError异常。
###1.3 本地方法栈
&emsp;&emsp;本地方法栈与虚拟机栈类似，区别：一个是执行java方法，一个是执行native方法，本地方法栈也有StackOverFlow和OutOfMemoryError异常。
###1.4 Java堆
&emsp;&emsp;线程共享，存放对象实例，所有的对象实例以及数组都要在堆上分配。
&emsp;&emsp;OutOfMemoryError异常。
&emsp;&emsp;GC的主要区域。从内存回收的角度看，由于现在的收集器采用分代收集算法，所以Java堆可划分为新生代和老年代；再细致一点可划分为Eden区、From Survivor区、To Survivor区等。从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。
&emsp;&emsp;Java堆可以处理物理不连续上不连续的内存空间中。只要逻辑上是连续的即可。
###1.5 方法区
&emsp;&emsp;线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
&emsp;&emsp;OutOfMemoryError异常。
###1.6 运行时常量池
&emsp;&emsp;运行时常量池是方法区的一部分。用于存放编译器生成的各种字面常量和符号引用，这部分在类加载后进入方法区的运行时常量池。
&emsp;&emsp;除了编译期产生的常量，运行时也有可能产生新的常量，例如String的intern();
&emsp;&emsp;OutOfMemoryError异常
###1.7 直接内存
&emsp;&emsp;直接内存不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。
&emsp;&emsp;JDK1.4中新加入的NIO类，引入可一种基于通道与缓冲区的I/O方式，他可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，避免在Java堆和Native堆中来回复制数据。
&emsp;&emsp;OutOfMemoryError异常。
_ _ _

##2. HotSpot虚拟机对象

###2.1 对象创建
- 虚拟机遇到一条new指令，先去检查这个指令的参数是否能在常量池定位到一个类的符号引用，并且检查符号引用代表的类是否已被加载、解析和初始化过，如果没有就必须执行相应的类加载过程。
- 类加载检查通过后，九尾新生对象分配内存。对象所需内存的大小在类加载完成后就已确定。
- 在使用Serial、parNew等带Compact过程的收集器时，系统采用的内存分配方式是指针碰撞，在使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲类表方式来分配内存。（避免内存分配的线程冲突：CAS和本地线程分配缓冲TLAB）。
- 内存分配完后，虚拟机将分配的内存空间都初始化为零值，这可以保证代码中不用赋初值就可以直接使用。
- 最后对对象进行必要的设置：这是哪个类的实例、如何找到类的元数据信息、对象的hash码、对象GC分代年龄等等，这些保存在对象头中。根据虚拟机对象是否使用偏向锁对，对象头有不同的设置。



###2.2 对象的内存布局
&emsp;&emsp;在hostSpot虚拟机中，对象在内存中存储的布局可分为三部分;对象头、实例数据、对齐填充。
&emsp;&emsp;**对象头包括：**
1. 存储对象运行时的数据（hashCode、GC分代年龄、线程持有的锁：第二章47页）：这部分数据长度为32bit或64bit，官方称为“Mark Word”
1. 类型指针：即指向它的雷元数据的指针，通过这个指针来确定他是那个类的实例。
2. 如果是数组、则对象头中还有记录数组长度的数据。

&emsp;&emsp;**实例数据**：是对象真正存储的有效数据，也就是代码中定义的字段的内容。
&emsp;&emsp;**对齐填充**：不是必需的，保证对象大小是8字节的整数倍。
###2.3 对象的定位访问
* 句柄访问：Java堆会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据分别的地址信息。句柄访问的好处是reference中存储的是稳定的句柄地址，对象被移动时只会改变句柄中的实例数据指针，而reference本身不用修改。
* 直接指针访问：速度快，节省了一次指针定位的开销。HotSoot采用这用方式。