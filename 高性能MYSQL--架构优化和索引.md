#高性能MYSQL--架构优化和索引
##一.选择优化的数据类型
* 简单就好：简单数据类型操作通常需要更少的CPU周期。例如：整形比字符串操作代价更低，因为字符集和校对规则是字符比较比整形比较更加复杂。例如：1.用MySQL内置类型而不是字符串来存储时间。2.应该用整数型存储IP地址
* 避免使用null：MYSQL难以优化可空列的查询，他会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，哈需要在MYSQL内部进行特殊处理。可空列被索引的时候，每条记录都需要一个额外的字节，还能导致MyISAMYSQL中固定大小的索引变为可变大小的索引。如果要对列进行索引，就要避免把他设置成为可空。

* 整数类型：mysql可为整数指定宽度，例如INT(11)，但他不会限制值得范围，只用来规定与mysql客户端交互时显示的字符个数。对于存储和计算来说，INT(1)和INT(11)是一样的
* 实数：DECIMAL类型最多允许65个数字,MySQL 5.0以上把数字保存到一个二进制字符串中（没每4个字节保存9个数字）。例如DECIMAL（18，9）将会在小数点前后保留9个数字，总共使用9个字节：小数点前4个字节，小数点1个字节，小数点后4个字节。DECIMAL在计算式时会被转换成DOUBLE，**MySQL在内部对浮点类型使用DOUBLE进行计算**。只在需要对小鼠进行精确计算是时才采用DECIMAL，比如保存金融数据。
* VARCHAR和CHAAR：
    * VARCHAR只占用需要的空间，因此比固定长度类型占用更少的存储空间。VARCHAR会使用额外的1~2字节来存储长度，<255使用1字节，否则使用2字节。eg:VARCHAR(1000)占用1002字节，它使用2字节来保存长度信息。会保留末尾的空格。**当最大长度远大于平均长度；很少发生更新时，因为这时候碎片不会成为问题**。
    * CHAR保存时会去掉末尾的空格，对于经常改变的值，CHAR优于VARCHAR，因为固定长度的行不容易产生碎片；对于很短的列，CHAR效率优于VARCHAR,因为没有长度字节。
* 日期和时间类型
    - TIMESTAMP：1970.1.1~2038，只使用4字节，显示的值依赖于时区,允许的时间范围较小。如果存储时没有指定值，默认设为当前时间（默认为not null），插入一行记录时，MySQL默认也会更新第一个TIMESTAMP列的值（除非update语句明确指定了值）
    - DATETIME：1001~9999，精度为秒，把日期和时间封装到一个格式为YYYYMMDDHHMMSS的整数中，与时区无关，使用8字节存储。
- BLOB和TEXT
    - BLOB和TEXT分别采用二进制和字符方式存储
    - BLOB存储的是二进制，没有排序规则或者字符集；TEXT类型有字符集和排序规则
&emsp;&emsp;通常使用TIMESTAMP，因为他更省空间。

* 太多的关联：mysql限制每个关联操作最多只能有61张表。一个粗略的经验：如果希望执行的快并且并发好，单个查询最好在12个表以内。

*计数器表（4.4.2）：如果应用在表总保存计数器，则在更新数据时可能会碰到并发问题，因为一般计数器表都只有一行数据，对于任何想要更新这一行的事务来说买这条记录都有一个全局的互斥锁，这使得这些事务只能串行执行。想要获得更高的并发性能，可以将计数器保存在多个行中，每次随机选择一行进行更新，统计时对所有行求和。

            以前是：create table counter (cnt int unsigned not null);
            更新：update counter set cnt = cnt + 1;

            现在：create table counter (tinyint unsigned not null primary key,cnt int int unsigned nto null);
            然后预先往表里存100条数据
            更新: update counter set cnt = cnt + 1 where slot = RAND() * 100;

##二.索引
1. 索引的优点：
    - 索引大大减少了服务器需要扫描的数据量
    - 索引可以帮助服务器避免排序和临时表
    - 索引可以将随机IO变为顺序IO
1. B-Tree索引
    * 局限：
        - 如果查找没从索引列的最左边开始，他就没什么用
        - 不能跳过索引中的列
        - 存储引擎不能优化任何在第一个范围条件右边的列。
2. 哈希索引
    * 局限：
        - 哈希索引只包含哈希码和行指针，而不是值本身，MySQL不能使用索引中的值来避免读取行。
        - MySQL不能使用哈希索引来排序
        - 哈希索引不支持按部分索引查找，因为他们是由被索引的全部值计算出来的。
        - 访问哈希索引中的数据非常快，除非碰撞率非常高。发生碰撞时，存储引擎必须访问链表中的每一个行指针，然后逐行进行数据比较，已确定正确的数据。
        - 如果有很多碰撞，维护索引就会变得很慢，例如删除（需逐行检查）。
        - 只支持等值比较
    - InnoDB有意向“自适应哈希索引”的功能，当InnoDB注意到某些索引值用的非常频繁时， 会在内存中基于B-Tree索引之上再创建一个哈希索引
3. 在查询语句中，索引应是独立的列（不能是表达式的一部分，也不能是函数的参数）
##三.InnoDB索引
###3.1
&emsp;&emsp;由于聚集索引是InnoDB中的表，所以不会像MyISAMySQL那样需要单独的行存储空间。
&emsp;&emsp;聚集索引的每个叶子节点都包含主键值、事务ID、用于ID和MVCC的回滚指针及剩下的列。如果主键被创建在列的前缀上，InnoDB也会包含整个列及剩下的所有列。InnoDB中的第二索引和聚集索引很不一样，InnoDB的第二索引叶子节点包含了主键值作为指向行的指针，而不是行指针。使用行的主键值作为指针使得索引变得更大，但这意味着In噢DB可以移动行，而无需更新指针。</br>
&emsp;&emsp;[聚集索引和非聚集索引对比](/Users/jingjie/Documents/markdown/images/高性能MYSQL/聚集索引和非聚集索引对比.jpg)</br>
&emsp;&emsp;InnoDB最好使用AUTO_INCREMENT列，这会保证行是顺序插入的并且能提高使用主键联接的性能。最好避免随机（乱序）聚集键，例如使用UUID（例如使用VRAHCRA作为主键）值是不好的选择，它使得聚集索引插入是随机的，这是最坏的情形，并且使数据聚集完全没有帮助，这会造成主键更大、分页和碎片、频繁的数据移动。以下是缺点总结：
* 目标页面也许会被刷到磁盘上并且从缓存中移走，无论哪种情况，InnoDB都不得不在插入新行之前从磁盘上找到并读取它。这导致大量的随机IO。
* InnoDB有事不得不进行分页，为新行开辟空间。这会导致大量数据移动。
* 页面会因为分页而变得稀疏和不规则地被填充，因此最终的数据会有碎片。
&emsp;&emsp;但主键顺序在高并发环境下会造成InnoDB内部单点竞争。这个“热点”是主键的上界。因为所有的插入都在那，并发插入会竞争一个AUTO_INCREMENT锁。
###3.2覆盖索引
&emsp;&emsp;如果一个索引包含所有需要查询的字段的值，就称之为“覆盖索引”。不是索引类型的索引都可以成为覆盖索引，覆盖索引必须存储索引列的值。
&emsp;&emsp;只读取索引而不是数据的优势
* 索引的记录比数据小，可以放在内存中，能极大的减小数据的访问量，这对缓存的负载很重要，它大部分时间都在拷贝数据上。
* 索引数据是按照列值顺序进行存储的，因此IO密集型范围访问会比随机地从磁盘上提取每一行要快得多。
* 覆盖索引对于InnoDB表特别有用，因为InnoDB的聚集索引。InnoBD的第二索引在叶子节点中保存了行的主键值。因此覆盖了查询的第二索引在主键中避免了另一次索引的查找。
* 大部分存储引擎存缓存索引比缓存数据要好。因为操作系统缓存了给存储引擎的数据，访问他们需要数据调用，这也许会导致巨大的性能影响，尤其是那些系统调用占了数据访问中最大开销的负载。
###3.3聚簇索引
* 优点：
    * 可以把相关数据保存在一起，减小磁盘IO。
    * 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此聚簇索引中获取的数据通常比非聚簇索引更快。
    * 使用覆盖查询时可以直接使用叶节点的主键值。
* 缺点
    - 聚簇索引最大限度地提高了IO密集型应用的性能，但如果数据全部，都存在内存中，则访问的顺序就没那么重要了，聚簇索引也就没有什么优势了。
    - 插入速度严重依赖于插入顺序。
    - 更新索引的代价很大
    - 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题。
    - 聚簇索引可能导致全表扫描变慢，尤其是比较稀疏，或者由于页分裂导致数据存储不连续的时候。
    - 二级索引（非聚簇索引）可能比想象的大，因为二级索引的叶子节点包含了引用行的主键列。
    - 二级索引访问需要两次索引查找，而不是一次。
###3.4 利用索引扫描做排序
&emsp;&emsp; 只有当索引的顺序和ORDER BY子句的顺序完全一致，并且排序方向（倒序或正序）都一样时，MYSQL才能使用索引来对结果做排序。ORDER BY子句和查找的限制是一样的：需要满足最左前缀的要求，或者如果WHERE子句/JOIN子句中对这些列制定了常量（索引的左前缀为常量）就可以弥补索引的不足。

**InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排它（写）锁**

##4.索引实例研究

### 4.1 多余索引
&emsp;&emsp;多余索引和重复索引有些不同，例如（A，B）上有索引，那么列（A）上的索引就是多余的。索引（A）相当于（A, ID）,(A,B)相当于（A,B,ID）。

###4.2 多种条件过滤
* 如果范围较小，可以用IN()来代替between
* 将范围查询的条件放在最后，这样可以用更多的索引。
