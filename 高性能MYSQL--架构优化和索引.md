#高性能MYSQL--架构优化和索引
##一.选择优化的数据类型
* 避免使用null：MYSQL难以优化可空列的查询，他会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，哈需要在MYSQL内部进行特殊处理。可空列被索引的时候，每条记录都需要一个额外的字节，还能导致MyISAMYSQL中固定大小的索引变为可变大小的索引。如果要对列进行索引，就要避免把他设置成为可空。

* 实数：DECIMAL类型最多允许65个数字,MySQL 5.0以上把数字保存到一个二进制字符串中（没每4个字节保存9个数字）。例如DECIMAL（18，9）将会在小数点前后保留9个数字，总共使用9个字节：小数点前4个字节，小数点1个字节，小数点后4个字节。DECIMAL在计算式时会被转换成DOUBLE，**MySQL在内部对浮点类型使用DOUBLE进行计算**。只在需要对小鼠进行精确计算是时才采用DECIMAL，比如保存金融数据。
* VARCHAR和CHAAR：
    * VARCHAR只占用需要的空间，因此比固定长度类型占用更少的存储空间。VARCHAR会使用额外的1~2字节来存储长度，<255使用1字节，否则使用2字节。eg:VARCHAR(1000)占用1002字节，它使用2字节来㽾长度信息。会保留末尾的空格。**当最大长度远大于平均长度，且很少发生更新时，适用于VARCHAR，因为这时候碎片不会成为问题**。
    * CHAR保存时会去掉末尾的空格，对于经常改变的值，CHAR优于VARCHAR，因为固定长度的行不容易产生碎片，对于很短的列，CHAR效率优于VARCHAR,因为没有长度字节。
* 日期和时间类型
    - TIMESTAMP：1970.1.1~2038，只使用4字节，显示的值依赖于时区。
    - DATETIME：1001~9999，精度为秒，把日期和时间封装到一个格式为YYYYMMDDHHMMSS的整数中，与时区无关，使用8字节存储。
&emsp;&emsp;通常使用TIMESTAMP，因为他更省空间。

##二.索引
1. 索引的优点：
    - 索引大大减少了服务器需要扫描的数据量
    - 索引可以帮助服务器避免排序和临时表
    - 索引可以将随机IO变为顺序IO
1. B-Tree索引
    * 局限：
        - 如果查找没从索引列的最左边开始，他就没什么用
        - 不能跳过索引中的列
        - 存储引擎不能优化任何在第一个范围条件右边的列。
2. 哈希索引
    * 局限：
        - 哈希索引只包含哈希码和行指针，而不是值本身，MySQL不能使用索引中的值来避免读取行。
        - MySQL不能使用哈希索引来排序
        - 哈希索引不支持部分建排序，因为他们是由被索引的全部值计算出来的。
        - 访问哈希索引中的数据非常快，除非碰撞率非常高。发生碰撞时，存储引擎必须访问链表中的每一个行指针，然后逐行进行数据比较，已确定正确的数据。
        - 如果有很多碰撞，维护索引就会变得很慢，例如删除（需逐行检查）。
3. 在查询语句中，索引应是独立的列（不能是表达式的一部分，也不能是函数的参数）
##三.InnoDB索引
###3.1
&emsp;&emsp;由于聚集索引是InnoDB中的表，所以不会像MyISAMySQL那样需要单独的行存储空间。
&emsp;&emsp;聚集索引的每个叶子节点都包含主键值、事务ID、用于ID和MVCC的回滚指针及剩下的列。如果主键被创建在列的前缀上，InnoDB也会包含整个列及剩下的所有列。InnoDB中的第二索引和聚集索引很不一样，InnoDB的第二索引叶子节点包含了主键值作为指向行的指针，而不是行指针。使用行的主键值作为指针使得索引变得更大，但这意味着In噢DB可以移动行，而无需更新指针。</br>
&emsp;&emsp;[聚集索引和非聚集索引对比](/Users/jingjie/Documents/markdown/images/高性能MYSQL/聚集索引和非聚集索引对比.jpg)</br>
&emsp;&emsp;InnoDB最好使用AUTO_INCREMENT列，这会保证行是顺序插入的并且能提高使用主键联接的性能。最好避免随机（乱序）聚集键，例如使用UUID（例如使用VRAHCRA作为主键）值是不好的选择，它使得聚集索引插入是随机的，这是最坏的情形，并且使数据聚集完全没有帮助，这会造成主键更大、分页和碎片、频繁的数据移动。以下是缺点总结：
* 目标页面也许会被刷到磁盘上并且从缓存中移走，无论哪种情况，InnoDB都不得不在插入新行之前从磁盘上找到并读取它。这导致大量的随机IO。
* InnoDB有事不得不进行分页，为新行开辟空间。这会导致大量数据移动。
* 页面会因为分页而变得稀疏和不规则地被填充，因此最终的数据会有碎片。
&emsp;&emsp;但主键顺序在高并发环境下会造成InnoDB内部单点竞争。这个“热点”是主键的上界。因为所有的插入都在那，并发插入会竞争一个AUTO_INCREMENT锁。
###3.2覆盖索引
&emsp;&emsp;如果一个索引包含所有需要查询的字段的值，就称之为“覆盖索引”。不是索引类型的索引都可以成为覆盖索引，覆盖索引必须存储索引列的值。
&emsp;&emsp;只读取索引而不是数据的优势
* 索引的记录比数据小，可以放在内存中，能极大的减小数据的访问量，这对缓存的负载很重要，它大部分时间都在拷贝数据上。
* 索引数据是按照列值顺序进行存储的，因此IO密集型范围访问会比随机地从磁盘上提取每一行要快得多。
* 覆盖索引对于InnoDB表特别有用，因为InnoDB的聚集索引。InnoBD的第二索引在叶子节点中保存了行的主键值。因此覆盖了查询的第二索引在主键中避免了另一次索引的查找。
* 大部分存储引擎存缓存索引比缓存数据要好。因为操作系统缓存了给存储引擎的数据，访问他们需要数据调用，这也许会导致巨大的性能影响，尤其是那些系统调用占了数据访问中最大开销的负载。
###3.3聚簇索引
* 优点：
    * 可以把相关数据保存在一起，减小磁盘IO。
    * 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此聚簇索引中获取的数据通常比非聚簇索引更快。
    * 使用覆盖查询时可以直接使用叶节点的主键值。
* 缺点
    - 聚簇索引最大限度地提高了IO密集型应用的性能，但如果数据全部，都存在内存中，则访问的顺序就没那么重要了，聚簇索引也就没有什么优势了。
    - 插入速度严重依赖于插入顺序。
    - 更新索引的代价很大
    - 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题。
    - 聚簇索引可能导致全表扫描变慢，尤其是比较稀疏，或者由于页分裂导致数据存储不连续的时候。
    - 二级索引（非聚簇索引）可能比想象的大，因为二级索引的叶子节点包含了引用行的主键列。
    - 二级索引访问需要两次索引查找，而不是一次。
###3.4 利用索引扫描做排序
&emsp;&emsp; 只有当索引的顺序和ORDER BY子句的顺序完全一致，并且排序方向（倒序或正序）都一样时，MYSQL才能使用索引来对结果做排序。ORDER BY子句和查找的限制是一样的：需要满足最左前缀的要求，或者如果WHERE子句/JOIN子句中对这些列制定了常量（索引的左前缀为常量）就可以弥补索引的不足。

**InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排它（写）锁**

##4.索引实例研究

### 4.1 多余索引
&emsp;&emsp;多余索引和重复索引有些不同，例如（A，B）上有索引，那么列（A）上的索引就是多余的。索引（A）相当于（A, ID）,(A,B)相当于（A,B,ID）。

###4.2 多种条件过滤
* 如果范围较小，可以用IN()来代替between
* 将范围查询的条件放在最后，这样可以用更多的索引。
