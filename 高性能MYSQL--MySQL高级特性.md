#MySQL高级特性
##一.分区表
&emsp;&emsp;分区表与多个相关的底层表实现，分区表的索引只是在各个底层表上各自加上一个完全相同的索引。在存储引擎的角度上。底层表和普通表没有任何区别，存储引擎无需知道这是一个普通表还是一个分区表的一部分。
* 可能会出问题：
    - NULL值回事分区过滤无效：分区的表达式的值可以是null：第一个任务是一个特殊的分区。假设按照PARTITION BY RANGE YEAR（order_date）分区，如果order_date为null或者是一个非法值，记录都会被放到第一个分区。这样查询的时候，就会检查两个分区而不是一个。如果第一个分区过大，代价会非常大。为了避免这种情况，可以创建一个无用的第一个分区：PARTITION p_nulls VALUE LESS THAN(0)。如果数据是一有效的，那么第一个分区就是空的，这样即使需要检查第一个分区，代价也很小。
    - 分区列和索隐裂不匹配：这会导致查询无法进行分区过滤。例如在a列上定义了索引，在b列上进行分区。由于每个分区内都有其独立的索引，所以扫描列b上的索引就需要扫描每一个分区内的对应的索引。
    - 操作分区表的成本：每次操作都需要打开并锁住底层数据表，考虑将多次操作在批量操作中集成。
    - 分区数量：由于MYSQL线性扫描数据表，分区数量过大会导致查询效率降低，因此需限制分区的数量。
    - 维护分区的成本：某些维护分区的操作速度很快，例如新增或删除分区。但有些操作例如充足或者类似ALTER语句的操作：这类操作会复制数据。重组的原理与ALTER类似，先创建一个临时的分区，然后将数据复制到其中，最后再删除原分区。
* 查询优化：对于访问分区表来说，很重要的一点是要在WHERE条件中带入分区，这样可以过滤掉无需访问的分区。**MYSQL只能在使用分区函数的列本身进行比较时才能过滤分区，而不能根据表达式的值去过滤分区,即使这个表达式是分区函数也不行** 例如：

        select * from sales where day > ‘2011-01-01’就可以过滤分区
        而
        select * from sales where YEAR(day) = 2010就不能过滤分区
* 触发器:
    - 对于每个表的每一个事件，最多自能定义一个触发器（eg:不能再 after insert上定义两个触发器）
    - MySQL只支持“基于行的触发”--触发器始终是针对一条记录的，而不是针对整个SQL语句的。如果变更的数据非常大，效率会很低。
* 绑定变量：MYSQL使用绑定变量的时候可以更高效的执行大量重复的语句。
    - 在服务器端只需要解析一次SQL语句
    - 在服务器端某些优化器的工作只需要执行一次，因为他会缓存一部分的执行计划。
    - 以二进制的方式只发送参数和句柄，比起每次都发送ASCII码文本效率更高。一个二进制的日期字段只需要三个字节，但如果是ASCII码则需要十个字节。二进制协议在客户端可以节省很多内存，减少了网络开销，还节省了将数据从存储原始格式转换成文本格式的开销。
    - 仅仅是参数-而不是整个查询语句-需要发送到服务器端，所以网络开销会更小。
    - MYSQL在存储参数的时候，直接将其放入缓存，不需要在内存中多次复制。
*  绑定变量的优化：对于绑定变量的SQL，MYSQL能够缓存器部分执行计划，如果某些执行计划需要根据传入的参数来计算时，MYSQL就无法存储这部分的执行计划。
    - 在准备阶段：服务器解析SQL语句，移除不可能的条件，并且重写子查询。
    - 第一次执行：如果可能的话，服务器会简化嵌套循环的关联，并将外关联转化为内关联。
    - 每次执行时：
        - 过滤分区
        - 尽量移除COUNT（）、min（）、max（）
        - 移除常量表达式
        - 检测常量表
        - 做必要的等值传播
        - 分析和优化ref、range和索引优化等访问数据的方法
        - 优化关联顺序。
* 查询缓存：MYSQL查询缓存保存了完整的结果。当查询命中该缓存，MYSQL会立刻返回结果，跳过了解析、优化和执行阶段。如果这个表发生了变化，这个表的缓存都会失效。
    - MYSQL判断命中缓存的方式：缓存放在一个索引表中，通过一个哈希值引用（包含了查询本身、当前数据库、客户端协议版本等影响返回结果的信息）。任何字符上的不同（空格、注释，任何的不同都会导致缓存不命中）。任何存在不确定函数的语句 都会导致结果不会被缓存
    - 打开缓存对读和写都会带来额外的消耗：
        - 读查询开始前必须先判断是否命中缓存
        - 如果这个读查询时可缓存的，那么执行完后，MYSQL发现查询缓存中没有这个查询，会把结果存入缓存，这会带来额外的消耗。
        - 对写操作也有影响。当向表写入数据时，MYSQL必须将对应表的所有缓存失效。如果缓存非常大或者碎片特别多，这个操作可能会带来很大的系统消耗。
    - 长时间运行的事务会大大降低查询缓存的命中率。（事务中有写操作，在这个事务提交前，这个表的相关查询无法被缓存）
    - 缓存失效操作需要全局锁保护，因此如果缓存巨大，可能会导致系统僵死一会。
    - 通用查询缓存优化：
        - 用多个小表替代一个大表，这会使得失效策略在一个更合适的粒度上。
        - 批量写入时只需要一次缓存失效，比单条写更好。
        - 控制缓存空间大小，太大可能会导致失效时服务器僵死。
        - 对于写密集型的应用，关闭缓存。
