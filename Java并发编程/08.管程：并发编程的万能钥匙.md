# 08.管程：并发编程的万能钥匙

### 什么是管程
Java采用的是管程技术，synchronized关键字及wait(),notify(),notifyAll()这三个方法都是管程的组成部分。而管程和信号量（信号量可以解决所有的并发问题）是等价的，所谓等价就是**能用管程实现信号量，也能用信号量实现管程。所谓管程，指的是管理共享变量以及对共享变量操作的过程，并让他们支持并发。**

### MESA模型
并发编程的两大核心问题：1.互斥，即同一时刻只允许一个线程访问共享资源；2.同步，即线程之间如何通信、协作。

管程是如何解决互斥的？

思路就是将共享变量及其对共享变量的操作统一封装起来。管程X将共享变量queeu这个队列和相关的操作入队enq()、出队deq()都封装起来，线程A和线程B如果想访问共享变量queue，只能通过enq()和deq()，而这两个方法保证互斥，只允许一个线程进入管程。

[管程模型的代码性语义](../images/Java并发/管程模型的代码性语义.png)

管程如何解决线程间的同步问题呢？

[MESA管程模型](../images/Java并发/MESA模型.png)

管程里引入了条件变量的概念，而且每个条件变量都对应一个等待队列，如上图，条件变量A和B都有自己的等待队列。条件变量和等待队列就是为了解决线程同步的问题。

加入线程T1执行出队操作，而队列不为空就是管程里的条件变量。如果发现队列为空，就去条件变量对于的队列里等待（通过wait()实现），此时线程T1就去“队列不空”这个条件变量的等待队列里等待。

之后线程T2执行入队操作，入队成功之后，“队列不空”这个条件已满足，此时线程T2要通知T1（通过notify()实现），当线程T1接到通知之后，会从等待队列里出来，但是出来之后不是马上执行，而是重新进入到入口等待队列里。

代码如下：
```Java
public class BlockedQueue<T> {
  final Lock lock =
    new ReentrantLock();
  // 条件变量：队列不满  
  final Condition notFull =
    lock.newCondition();
  // 条件变量：队列不空  
  final Condition notEmpty =
    lock.newCondition();

  // 入队
  void enq(T x) {
    lock.lock();
    try {
      while (队列已满){
        // 等待队列不满
        notFull.await();
      }  
      // 省略入队操作...
      // 入队后, 通知可出队
      notEmpty.signal();
    }finally {
      lock.unlock();
    }
  }
  // 出队
  void deq(){
    lock.lock();
    try {
      while (队列已空){
        // 等待队列不空
        notEmpty.await();
      }
      // 省略出队操作...
      // 出队后，通知可入队
      notFull.signal();
    }finally {
      lock.unlock();
    }  
  }
}
```

### wait()的正确姿势
对于MESA管程来说，有一个编程范式，就是需要在一个while中循环调用wait()。这个是MESA管程特有的。

```Java
while(条件不满足) {
  wait();
}
```

Hasen模型、Hoare模型和MESA模型的一个核心区别就是当条件满足后，如何通知相关线程，让同一时刻只有一个线程可以执行。

1. Hasen模型里，要求notify()放在代码最后，这样T2通知完T1后，T2就结束了，然后T1再执行，这样就保证同一时刻只有一个线程在执行。
2. Hoare模型里，T2通知完T1后，T2阻塞，T1马上执行，T1执行完后，在唤醒T2，也能保证通知同一时刻只有一个线程在执行，但是相比Hasen模型，T2多了一次阻塞和唤醒操作。
3. MESA管程里，T2通知完T1后，T2还是会继续执行，T1并不立即执行，仅仅是从条件变量的等待队列进入到入口等待队列里，这样的好处是notify不用放到代码的最后，T2也没有多余的唤醒操作。但是也有个副作用，就是当T1再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环的方式检验条件变量。

### notify()何时可以使用
之前说过**除非经过深思熟虑，否则尽量使用notifyAll()**,那么什么时候使用notify()呢？满足一下是哪个条件

1. 所有等待线程拥有相同的等待条件
2. 所有等待线程被唤醒后，执行相同的操作
3. 只需要唤醒一个线程

例如对于上面的阻塞队列的例子，对于“队列不满”这个条件变量，其阻塞队列里等待的线程都是在等待这个条件，反应在代码里就是这三行，关键是while里面的等待条件时完全相同的：
```Java
while (队列已满){
  // 等待队列不满
  notFull.await();
}
```
所有等待线程被唤醒后，执行的操作也是一样的：
```Java
// 省略入队操作...
// 入队后, 通知可出队
notEmpty.signal();
```

同时也满足第三个条件：只需要一个线程被唤醒

MESA模型的条件变量可以有很多个，Java对MESA的模型进行了精简，java的内置管程里条件变量只有一个：


[java中的管程示意图](../images/Java并发/java中的管程示意图.png)

java内置的管程方案使用简单，synchronized关键字修饰的代码块，在编译期会自动生成相关加锁和解锁代码，但仅支持一个条件变量，而JAVA SDK并发包实现的管程支持多个条件变量，但需要自己进行加锁和解锁操作。
